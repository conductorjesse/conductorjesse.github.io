<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Recursion - Supporting every technical founder on their lab-to-market journey</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* ===== BASE STYLES ===== */
        body {
            font-family: 'Inter', sans-serif;
            background: linear-gradient(135deg, #0f172a 0%, #1e293b 50%, #334155 100%);
            color: #f1f5f9;
            overflow-x: hidden;
        }

        /* ===== GAME CANVAS ===== */
        #game-canvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        /* ===== LANDING PAGE STYLES ===== */
        .hero-gradient {
            background: linear-gradient(135deg, #1e40af 0%, #3b82f6 50%, #60a5fa 100%);
        }

        .card-glass {
            background: rgba(30, 41, 59, 0.8);
            backdrop-filter: blur(20px);
            border: 1px solid rgba(59, 130, 246, 0.2);
        }

        .btn-primary {
            background: linear-gradient(135deg, #3b82f6, #1d4ed8);
            transition: all 0.3s ease;
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 25px rgba(59, 130, 246, 0.4);
        }

        .btn-secondary {
            background: rgba(30, 41, 59, 0.8);
            border: 1px solid rgba(59, 130, 246, 0.3);
            transition: all 0.3s ease;
        }

        .btn-secondary:hover {
            background: rgba(59, 130, 246, 0.1);
            border-color: rgba(59, 130, 246, 0.5);
        }

        .game-container {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 50;
        }

        .game-container.active {
            display: block;
        }

        .game-section-modal {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 100;
            max-width: 90vw;
            max-height: 90vh;
            background: rgba(15, 23, 42, 0.95);
            backdrop-filter: blur(20px);
            border: 1px solid rgba(59, 130, 246, 0.2);
            border-radius: 12px;
            padding: 2rem;
            box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.5);
        }

        .game-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            z-index: 99;
            display: none;
        }

        .game-overlay.active {
            display: block;
        }

        .win-message {
            transition: opacity 0.5s ease, transform 0.5s ease;
        }

        .fade-in {
            animation: fadeIn 0.6s ease-out;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .slide-up {
            animation: slideUp 0.8s ease-out;
        }

        @keyframes slideUp {
            from { opacity: 0; transform: translateY(40px); }
            to { opacity: 1; transform: translateY(0); }
        }
    </style>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800&display=swap" rel="stylesheet">
</head>
<body class="min-h-screen">

    <!-- Landing Page -->
    <div id="landing-page" class="min-h-screen">
        <!-- Navigation -->
        <nav class="relative z-10 p-6">
            <div class="max-w-7xl mx-auto flex justify-between items-center">
                <div class="text-2xl font-bold text-white">Recursion</div>
            </div>
        </nav>

        <!-- Hero Section -->
        <section class="relative py-20 px-6">
            <div class="max-w-7xl mx-auto text-center">
                <h1 class="text-6xl md:text-8xl font-bold text-white mb-6 slide-up">
                    We Exist to Help Scientists Win.
                </h1>
                <p class="text-xl md:text-2xl text-blue-200 mb-12 max-w-4xl mx-auto fade-in">
                    We empower scientific innovators to deploy world-changing climate technologies through commercial skills, risk tolerance, and community support.
                </p>
                <div class="flex flex-col sm:flex-row gap-4 justify-center fade-in">
                    <button id="try-recursion-btn" class="btn-primary text-white px-8 py-4 rounded-lg font-semibold text-lg">
                        Try Recursion
                    </button>
                    <a href="mailto:info@recursionworks.com" class="btn-secondary text-white px-8 py-4 rounded-lg font-semibold text-lg">
                        Get in touch
                    </a>
                </div>
            </div>
        </section>

        <!-- What We Do Section -->
        <section class="py-20 px-6">
            <div class="max-w-7xl mx-auto">
                <h2 class="text-4xl md:text-5xl font-bold text-white mb-12 text-center">What We Do</h2>
                <div class="max-w-4xl mx-auto">
                    <p class="text-lg text-blue-200 mb-8 leading-relaxed">
                        We provide hands-on coaching and strategic guidance to scientists and early-stage teams. Our core methodology uses techno-economic analysis (TEA) as a strategic framework to drive decision-making and action.
                    </p>
                    <div class="grid md:grid-cols-3 gap-8 mb-12">
                        <div class="card-glass p-6 rounded-lg">
                            <h3 class="text-xl font-semibold text-white mb-4">Coaching & Support</h3>
                            <p class="text-blue-200">6-8 week TEA development sprints to fractional weekly support with dedicated commercial bandwidth.</p>
                        </div>
                        <div class="card-glass p-6 rounded-lg">
                            <h3 class="text-xl font-semibold text-white mb-4">Programming</h3>
                            <p class="text-blue-200">Commercialization bootcamps, TEA workshops, and investor readiness training.</p>
                        </div>
                        <div class="card-glass p-6 rounded-lg">
                            <h3 class="text-xl font-semibold text-white mb-4">Train the Trainer</h3>
                            <p class="text-blue-200">University Climate Ventures program to reach scientists worldwide through faculty and curriculum.</p>
                        </div>
                    </div>
                </div>
            </div>
        </section>

        <!-- Game Overlay -->
        <div id="game-overlay" class="game-overlay"></div>
        
        <!-- Game Section Modal (initially hidden) -->
        <div id="game-section" class="game-section-modal hidden" onclick="event.stopPropagation()">
            <div class="flex justify-between items-center mb-4">
                <h3 class="text-2xl font-bold text-white">Try Recursion</h3>
                <button id="close-game-btn" class="text-gray-400 hover:text-white text-2xl font-bold">&times;</button>
            </div>
            <div class="flex justify-end mb-4">
                <button id="reset-button" class="btn-secondary text-white font-bold py-2 px-4 rounded-lg text-sm">Reset</button>
            </div>
            <div class="relative" style="height: 400px; overflow: hidden;">
                <canvas id="game-canvas" style="width: 100%; height: 400px; border-radius: 8px;"></canvas>
                
                <!-- Win Message -->
                <div id="win-message" class="absolute inset-0 flex items-center justify-center bg-black bg-opacity-70 opacity-0 transform scale-95 pointer-events-none z-20 rounded-lg">
                    <div class="text-center">
                        <h2 class="text-4xl font-extrabold text-green-400 mb-4">You Win!</h2>
                        <p class="text-xl text-blue-200">Congratulations! You've mastered the puzzle.</p>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Footer -->
    <footer class="py-16 px-6 bg-slate-900/50">
        <div class="max-w-7xl mx-auto text-center">
            <h2 class="text-3xl md:text-4xl font-bold text-white mb-6">Ready to Get Started?</h2>
            <p class="text-lg text-blue-200 mb-8 max-w-3xl mx-auto">
                Scientists commercializing research or supporters of climate innovation - let's connect!
            </p>
            <div class="flex flex-col sm:flex-row gap-4 justify-center mb-8">
                <a href="mailto:info@recursionworks.com" class="btn-primary text-white px-8 py-4 rounded-lg font-semibold text-lg">
                    Get in touch!
                </a>
            </div>
            <div class="border-t border-slate-700 pt-8">
                <div class="text-blue-300 mb-4">
                    <a href="mailto:info@recursionworks.com" class="hover:text-white transition-colors">info@recursionworks.com</a>
                </div>
                <div class="text-blue-300">
                    <a href="https://www.linkedin.com/company/recursionworks/about/" class="hover:text-white transition-colors" target="_blank" rel="noopener noreferrer">LinkedIn</a>
                </div>
            </div>
        </div>
    </footer>

    <script type="module">
        import * as THREE from 'https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.module.js';

        // ===== GAME CONSTANTS =====
        const GAME_CONFIG = {
            NUM_DISKS: 5,
            POLE_HEIGHT: 10, // 2x larger
            POLE_RADIUS: 0.2, // 2x larger
            BASE_WIDTH: 24, // 2x larger
            BASE_HEIGHT: 1.0, // 2x larger
            DISK_HEIGHT: 1.0, // 2x larger
            POLE_POSITIONS: [-8, 0, 8], // 2x larger spacing
            DISK_COLORS: [0xfb7185, 0xfb923c, 0xfacc15, 0x4ade80, 0x38bdf8, 0x818cf8, 0xc084fc],
            ANIMATION_SPEED: 0.05
        };

        // ===== THREE.JS SETUP =====
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000); // Reduced FOV from 75 to 45
        const renderer = new THREE.WebGLRenderer({ 
            canvas: document.getElementById('game-canvas'), 
            antialias: true, 
            alpha: true 
        });
        
        // Set initial size - will be updated when game is shown
        renderer.setSize(800, 600); // Default size
        renderer.setClearColor(0x000000, 0);

        // ===== LIGHTING SETUP =====
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
        scene.add(ambientLight);
        
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(5, 10, 7.5);
        directionalLight.castShadow = true;
        scene.add(directionalLight);

        // ===== GAME STATE =====
        const gameState = {
            towers: [[], [], []],
            disks: [],
            selectedDisk: null,
            sourcePole: -1,
            moveCount: 0,
            animationData: null,
            isDragging: false
        };

        // ===== UI ELEMENTS =====
        const ui = {
            resetButton: document.getElementById('reset-button'),
            winMessage: document.getElementById('win-message'),
            tryRecursionBtn: document.getElementById('try-recursion-btn'),
            gameSection: document.getElementById('game-section'),
            gameOverlay: document.getElementById('game-overlay'),
            closeGameBtn: document.getElementById('close-game-btn')
        };

        // ===== GAME OBJECTS =====
        const gameObjects = {
            base: null,
            poles: [],
            disks: [],
            dropZones: [] // Invisible larger areas for easier dropping
        };

        // Create base platform
        function createBase() {
            const baseGeometry = new THREE.BoxGeometry(
                GAME_CONFIG.BASE_WIDTH, 
                GAME_CONFIG.BASE_HEIGHT, 
                GAME_CONFIG.BASE_WIDTH / 2
            );
            const baseMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x4B5563, 
                roughness: 0.5 
            });
            
            gameObjects.base = new THREE.Mesh(baseGeometry, baseMaterial);
            gameObjects.base.position.y = -GAME_CONFIG.BASE_HEIGHT / 2;
            scene.add(gameObjects.base);
        }

        // Create poles
        function createPoles() {
            const poleGeometry = new THREE.CylinderGeometry(
                GAME_CONFIG.POLE_RADIUS, 
                GAME_CONFIG.POLE_RADIUS, 
                GAME_CONFIG.POLE_HEIGHT, 
                16
            );
            const poleMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x6B7280, 
                metalness: 0.5, 
                roughness: 0.3 
            });
            
            GAME_CONFIG.POLE_POSITIONS.forEach((pos, index) => {
                const pole = new THREE.Mesh(poleGeometry, poleMaterial);
                pole.position.set(pos, GAME_CONFIG.POLE_HEIGHT / 2, 0);
                pole.userData.isPole = true;
                pole.userData.poleIndex = index;
                scene.add(pole);
                gameObjects.poles.push(pole);
            });
        }

        // Create invisible drop zones (larger areas for easier dropping)
        function createDropZones() {
            const dropZoneGeometry = new THREE.CylinderGeometry(
                4.0, // 2x larger drop zone radius
                4.0, 
                GAME_CONFIG.POLE_HEIGHT, 
                16
            );
            const dropZoneMaterial = new THREE.MeshBasicMaterial({ 
                visible: false, // Invisible
                transparent: true,
                opacity: 0
            });
            
            GAME_CONFIG.POLE_POSITIONS.forEach((pos, index) => {
                const dropZone = new THREE.Mesh(dropZoneGeometry, dropZoneMaterial);
                dropZone.position.set(pos, GAME_CONFIG.POLE_HEIGHT / 2, 0);
                dropZone.userData.isDropZone = true;
                dropZone.userData.poleIndex = index;
                scene.add(dropZone);
                gameObjects.dropZones.push(dropZone);
            });
        }


        // Create disks
        function createDisks() {
            const diskGeometry = (radius) => new THREE.CylinderGeometry(
                radius, 
                radius, 
                GAME_CONFIG.DISK_HEIGHT, 
                32
            );
            
            for (let i = 0; i < GAME_CONFIG.NUM_DISKS; i++) {
                const radius = 3.0 - i * 0.4; // 2x larger radius range
                const material = new THREE.MeshStandardMaterial({ 
                    color: GAME_CONFIG.DISK_COLORS[i % GAME_CONFIG.DISK_COLORS.length], 
                    metalness: 0.2, 
                    roughness: 0.4 
                });
                
                const disk = new THREE.Mesh(diskGeometry(radius), material);
                disk.userData.diskId = i;
                disk.userData.radius = radius;
                gameObjects.disks.push(disk);
            }
        }

        // ===== GAME LOGIC =====
        function resetGame() {
            try {
                // Clear existing state
                gameState.towers = [[], [], []];
                gameObjects.disks.forEach(disk => scene.remove(disk));
                gameObjects.disks = [];
                
                // Recreate game objects
                createDisks();

                // Place disks on the first pole, largest at the bottom
                for (let i = 0; i < GAME_CONFIG.NUM_DISKS; i++) {
                    const disk = gameObjects.disks[i];
                    gameState.towers[0].push(disk);
                    scene.add(disk);
                    positionDiskOnPole(disk, 0);
                }

                // Reset UI and state
                gameState.moveCount = 0;
                gameState.selectedDisk = null;
                gameState.sourcePole = -1;
                gameState.animationData = null;
                gameState.isDragging = false;
                
                // Hide win message
                ui.winMessage.classList.add('opacity-0', 'scale-95', 'pointer-events-none');
            } catch (error) {
                console.error('Error resetting game:', error);
            }
        }

        function positionDiskOnPole(disk, poleIndex) {
            const yPos = gameState.towers[poleIndex].indexOf(disk) * GAME_CONFIG.DISK_HEIGHT + GAME_CONFIG.DISK_HEIGHT / 2;
            disk.position.set(GAME_CONFIG.POLE_POSITIONS[poleIndex], yPos, 0);
        }

        function checkWin() {
            if (gameState.towers[2].length === GAME_CONFIG.NUM_DISKS) {
                ui.winMessage.classList.remove('opacity-0', 'scale-95', 'pointer-events-none');
            }
        }

        // ===== INTERACTION SYSTEM =====
        const interaction = {
            raycaster: new THREE.Raycaster(),
            mouse: new THREE.Vector2(),
            dragPlane: new THREE.Plane(new THREE.Vector3(0, 1, 0), -(GAME_CONFIG.POLE_HEIGHT + 2)),
            intersectionPoint: new THREE.Vector3()
        };

        function getIntersectedTower() {
            interaction.raycaster.setFromCamera(interaction.mouse, camera);
            const objectsToIntersect = [
                ...gameObjects.dropZones, // Use drop zones instead of poles for easier targeting
                ...gameObjects.disks.filter(d => d !== gameState.selectedDisk)
            ];
            const intersects = interaction.raycaster.intersectObjects(objectsToIntersect);

            if (intersects.length > 0) {
                const clickedObject = intersects[0].object;
                if (clickedObject.userData.isDropZone) {
                    return clickedObject.userData.poleIndex;
                } else if (clickedObject.userData.diskId !== undefined) {
                    for (let i = 0; i < gameState.towers.length; i++) {
                        if (gameState.towers[i].includes(clickedObject)) {
                            return i;
                        }
                    }
                }
            }
            return -1;
        }
        
        function updateMouse(event) {
            const rect = renderer.domElement.getBoundingClientRect();
            interaction.mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
            interaction.mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
        }

        function onMouseDown(event) {
            if (gameState.animationData || gameState.isDragging) return;
            
            try {
                updateMouse(event);
                const poleIndex = getIntersectedTower();

                if (poleIndex !== -1) {
                    const sourceTower = gameState.towers[poleIndex];
                    if (sourceTower.length > 0) {
                        gameState.isDragging = true;
                        gameState.selectedDisk = sourceTower[sourceTower.length - 1];
                        gameState.selectedDisk.scale.set(0.85, 0.85, 0.85); // Minimal scaling needed with distant camera
                        gameState.sourcePole = poleIndex;

                        // Animate lifting the disk
                        gameState.animationData = {
                            disk: gameState.selectedDisk,
                            phase: 'up-only',
                            progress: 0,
                            startPos: gameState.selectedDisk.position.clone(),
                            endPos: new THREE.Vector3(
                                GAME_CONFIG.POLE_POSITIONS[poleIndex], 
                                GAME_CONFIG.POLE_HEIGHT + 1, 
                                0
                            )
                        };
                    }
                }
            } catch (error) {
                console.error('Error in onMouseDown:', error);
            }
        }

        function onMouseMove(event) {
            if (!gameState.isDragging || !gameState.selectedDisk) return;
            
            try {
                updateMouse(event);
                
                // Only move the disk with the mouse if its "lift" animation is complete
                if (gameState.animationData) return;

                interaction.raycaster.setFromCamera(interaction.mouse, camera);
                interaction.raycaster.ray.intersectPlane(
                    interaction.dragPlane, 
                    interaction.intersectionPoint
                );
                gameState.selectedDisk.position.copy(interaction.intersectionPoint);

                // Pole detection (no visual highlighting)
                const poleIndex = getIntersectedTower();
            } catch (error) {
                console.error('Error in onMouseMove:', error);
            }
        }

        function onMouseUp(event) {
            if (!gameState.isDragging || !gameState.selectedDisk) return;

            try {
                // Don't reset scale here - let the animation handle it
                gameState.isDragging = false;

                const targetPoleIndex = getIntersectedTower();
                const targetTower = targetPoleIndex !== -1 ? gameState.towers[targetPoleIndex] : null;
                const topDisk = (targetTower && targetTower.length > 0) ? targetTower[targetTower.length - 1] : null;
                const isValidMove = targetPoleIndex !== -1 && 
                    (!topDisk || gameState.selectedDisk.userData.radius < topDisk.userData.radius);

                if (isValidMove) {
                    // Place disk on the new tower
                    const sourceTower = gameState.towers[gameState.sourcePole];
                    sourceTower.pop();
                    targetTower.push(gameState.selectedDisk);
                    gameState.moveCount++;

                    gameState.animationData = {
                        disk: gameState.selectedDisk,
                        phase: 'down',
                        progress: 0,
                        startPos: gameState.selectedDisk.position.clone(),
                        endPos: new THREE.Vector3(
                            GAME_CONFIG.POLE_POSITIONS[targetPoleIndex], 
                            (targetTower.length - 1) * GAME_CONFIG.DISK_HEIGHT + GAME_CONFIG.DISK_HEIGHT / 2, 
                            0
                        )
                    };
                } else {
                    // Invalid move, return the disk to its original tower
                    const sourceTower = gameState.towers[gameState.sourcePole];
                    gameState.animationData = {
                        disk: gameState.selectedDisk,
                        phase: 'down',
                        progress: 0,
                        startPos: gameState.selectedDisk.position.clone(),
                        endPos: new THREE.Vector3(
                            GAME_CONFIG.POLE_POSITIONS[gameState.sourcePole], 
                            (sourceTower.length - 1) * GAME_CONFIG.DISK_HEIGHT + GAME_CONFIG.DISK_HEIGHT / 2, 
                            0
                        )
                    };
                }
                
                gameState.selectedDisk = null;
                gameState.sourcePole = -1;
            } catch (error) {
                console.error('Error in onMouseUp:', error);
            }
        }
        
        // ===== RENDERING & ANIMATION =====
        camera.position.set(0, 20, 35); // Pulled back further for larger components
        camera.lookAt(0, 4, 0);

        function animate() {
            requestAnimationFrame(animate);

            if (gameState.animationData) {
                const speed = GAME_CONFIG.ANIMATION_SPEED;
                gameState.animationData.progress += speed;
                
                if (gameState.animationData.phase === 'up') {
                    gameState.animationData.disk.position.lerp(
                        gameState.animationData.midPos, 
                        gameState.animationData.progress
                    );
                    if (gameState.animationData.progress >= 1) {
                        gameState.animationData.progress = 0;
                        gameState.animationData.phase = 'across';
                    }
                } else if (gameState.animationData.phase === 'across') {
                    // Skip to 'down' phase for simplicity
                    gameState.animationData.phase = 'down';
                    gameState.animationData.startPos = gameState.animationData.disk.position.clone();
                } else if (gameState.animationData.phase === 'down') {
                    gameState.animationData.disk.position.lerp(
                        gameState.animationData.endPos, 
                        gameState.animationData.progress
                    );
                    if (gameState.animationData.progress >= 1) {
                        gameState.animationData.disk.position.copy(gameState.animationData.endPos);
                        // Reset scale to normal size when placed
                        gameState.animationData.disk.scale.set(1, 1, 1);
                        checkWin();
                        gameState.animationData = null;
                    }
                } else if (gameState.animationData.phase === 'up-only') {
                    gameState.animationData.disk.position.lerp(
                        gameState.animationData.endPos, 
                        gameState.animationData.progress
                    );
                    if (gameState.animationData.progress >= 1) {
                        gameState.animationData.disk.position.copy(gameState.animationData.endPos);
                        gameState.animationData = null;
                    }
                }
            }
            
            renderer.render(scene, camera);
        }

        // ===== EVENT LISTENERS =====
        function onWindowResize() {
            try {
                const canvas = document.getElementById('game-canvas');
                const container = canvas.parentElement;
                const rect = container.getBoundingClientRect();
                
                // Only resize if container is visible and has dimensions
                if (rect.width > 0 && rect.height > 0) {
                    camera.aspect = rect.width / rect.height;
                    camera.updateProjectionMatrix();
                    renderer.setSize(rect.width, rect.height);
                }
            } catch (error) {
                console.error('Error resizing window:', error);
            }
        }

        function initializeEventListeners() {
            window.addEventListener('resize', onWindowResize);
            window.addEventListener('mousedown', onMouseDown);
            window.addEventListener('mousemove', onMouseMove);
            window.addEventListener('mouseup', onMouseUp);
            ui.resetButton.addEventListener('click', resetGame);
            ui.tryRecursionBtn.addEventListener('click', toggleGame);
            ui.closeGameBtn.addEventListener('click', closeGame);
            ui.gameOverlay.addEventListener('click', closeGame);
        }

        // ===== GAME TOGGLE FUNCTIONS =====
        function toggleGame() {
            if (ui.gameSection.classList.contains('hidden')) {
                ui.gameSection.classList.remove('hidden');
                ui.gameOverlay.classList.add('active');
                document.body.style.overflow = 'hidden'; // Prevent background scrolling
                // Wait for the modal to be visible, then initialize and reset
                setTimeout(() => {
                    onWindowResize();
                    // Create game objects if they don't exist
                    if (gameObjects.base === null) {
                        createBase();
                        createPoles();
                        createDropZones();
                    }
                    resetGame();
                }, 100);
            } else {
                closeGame();
            }
        }

        function closeGame() {
            ui.gameSection.classList.add('hidden');
            ui.gameOverlay.classList.remove('active');
            document.body.style.overflow = 'auto'; // Restore scrolling
        }

        // ===== INITIALIZATION =====
        function initializeGame() {
            try {
                initializeEventListeners();
                animate();
            } catch (error) {
                console.error('Error initializing game:', error);
            }
        }

        // Initialize the game (but don't create objects until needed)
        initializeGame();

    </script>
</body>
</html>



