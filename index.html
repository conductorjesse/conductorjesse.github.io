<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Recursive Block Diagram</title>
    <style>
        :root {
            --bg-color: #121212;
            --box-bg-color: #1e1e1e;
            --border-color: #3a3a3a;
            --glow-color: #00aaff;
            --arrow-color: #444444;
            --zoom-duration: 1.2s;
        }

        /* --- Basic Setup --- */
        html, body {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            background-color: var(--bg-color);
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
        }

        #viewport {
            position: relative;
            width: 100%;
            height: 100%;
        }

        /* --- Diagram Styling --- */
        .diagram-container {
            position: absolute;
            inset: 0;
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            grid-template-rows: repeat(2, 1fr);
            gap: 40px;
            padding: 50px;
            box-sizing: border-box;
            transform-origin: 0 0; /* Will be changed by JS */
            transition: transform var(--zoom-duration) cubic-bezier(0.42, 0, 0.58, 1);
        }

        .box {
            position: relative;
            background-color: var(--box-bg-color);
            border: 2px solid var(--border-color);
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            /* New diagrams start invisible and fade in after zoom */
            opacity: 1;
        }
        
        .box .diagram-container {
            opacity: 0;
            transition: opacity 0.5s ease 0.8s; /* Fade in after zoom animation */
        }
        
        .box:hover {
            border-color: var(--glow-color);
            box-shadow: 0 0 15px var(--glow-color), 0 0 5px var(--glow-color) inset;
            transform: scale(1.05);
        }

        /* --- Arrow Styling --- */
        .arrow {
            position: absolute;
            background: var(--arrow-color);
            z-index: -1;
        }
        .arrow.right { height: 4px; }
        .arrow.down { width: 4px; }
        .arrow.left { height: 4px; }
        .arrow.up { width: 4px; }
        .arrow::after {
            content: '';
            position: absolute;
            width: 0;
            height: 0;
            border-style: solid;
        }
        /* Arrowhead directions */
        .arrow.right::after { border-width: 8px 0 8px 12px; border-color: transparent transparent transparent var(--arrow-color); right: -12px; top: -6px; }
        .arrow.down::after { border-width: 12px 8px 0 8px; border-color: var(--arrow-color) transparent transparent transparent; bottom: -12px; left: -6px; }
        .arrow.left::after { border-width: 8px 12px 8px 0; border-color: transparent var(--arrow-color) transparent transparent; left: -12px; top: -6px; }
        .arrow.up::after { border-width: 0 8px 12px 8px; border-color: transparent transparent var(--arrow-color) transparent; top: -12px; left: -6px; }

        /* Positioning of individual arrows */
        #arrow-1-2 { top: 50%; left: 100%; width: 40px; transform: translateY(-50%); }
        #arrow-2-3 { top: 50%; left: 100%; width: 40px; transform: translateY(-50%); }
        #arrow-3-4 { top: 50%; left: 100%; width: 40px; transform: translateY(-50%); }
        #arrow-4-5 { left: 50%; top: 100%; height: 40px; transform: translateX(-50%); }
        #arrow-5-6 { top: 50%; right: 100%; width: 40px; transform: translateY(-50%); }
        #arrow-6-7 { top: 50%; right: 100%; width: 40px; transform: translateY(-50%); }
        #arrow-7-8 { top: 50%; right: 100%; width: 40px; transform: translateY(-50%); }
        #arrow-8-1 { left: 50%; bottom: 100%; height: 40px; transform: translateX(-50%); }
    </style>
</head>
<body>

    <div id="viewport">
        </div>

    <script>
        const viewport = document.getElementById('viewport');

        /**
         * Creates a complete diagram element with 8 boxes and arrows.
         * @returns {HTMLElement} The diagram container element.
         */
        function createDiagram() {
            const container = document.createElement('div');
            container.className = 'diagram-container';

            const boxesData = [
                { id: 1, gridPos: '1 / 1' }, { id: 2, gridPos: '1 / 2' },
                { id: 3, gridPos: '1 / 3' }, { id: 4, gridPos: '1 / 4' },
                { id: 8, gridPos: '2 / 1' }, { id: 7, gridPos: '2 / 2' },
                { id: 6, gridPos: '2 / 3' }, { id: 5, gridPos: '2 / 4' }
            ];
            
            const arrowsData = [
                { id: 'arrow-1-2', parent: 1, class: 'arrow right' }, { id: 'arrow-2-3', parent: 2, class: 'arrow right' },
                { id: 'arrow-3-4', parent: 3, class: 'arrow right' }, { id: 'arrow-4-5', parent: 4, class: 'arrow down' },
                { id: 'arrow-5-6', parent: 6, class: 'arrow left' },  { id: 'arrow-6-7', parent: 7, class: 'arrow left' },
                { id: 'arrow-7-8', parent: 8, class: 'arrow left' },  { id: 'arrow-8-1', parent: 1, class: 'arrow up' }
            ];

            const boxElements = {};

            // Create boxes
            boxesData.forEach(data => {
                const box = document.createElement('div');
                box.className = 'box';
                box.dataset.id = `box-${data.id}`;
                box.style.gridArea = data.gridPos;
                container.appendChild(box);
                boxElements[data.id] = box;
            });

            // Create and attach arrows to their parent boxes
            arrowsData.forEach(data => {
                const arrow = document.createElement('div');
                arrow.id = data.id;
                arrow.className = data.class;
                boxElements[data.parent].appendChild(arrow);
            });
            
            return container;
        }

        // --- Main Logic ---

        // Listen for clicks anywhere in the viewport
        viewport.addEventListener('click', function(event) {
            // Check if the clicked element is a box and doesn't already contain a zoomed diagram
            if (event.target.matches('.box') && !event.target.querySelector('.diagram-container')) {
                const box = event.target;
                const diagramContainer = box.parentElement;

                // Make other boxes in the same diagram unclickable
                diagramContainer.querySelectorAll('.box').forEach(b => {
                    if (b !== box) b.style.pointerEvents = 'none';
                });

                // 1. Calculate the scale factor needed to make the box fill the viewport
                const viewportWidth = viewport.clientWidth;
                const boxWidth = box.offsetWidth;
                const scale = viewportWidth / boxWidth;
                
                // 2. Calculate the position of the box relative to the viewport
                const boxRect = box.getBoundingClientRect();
                
                // 3. Set the transform-origin of the container to the center of the clicked box
                // We use getBoundingClientRect because it's relative to the viewport, which handles
                // any existing transforms on parent elements.
                const originX = boxRect.left + boxRect.width / 2;
                const originY = boxRect.top + boxRect.height / 2;
                diagramContainer.style.transformOrigin = `${originX}px ${originY}px`;
                
                // 4. Apply the scale transform to zoom in
                diagramContainer.style.transform = `scale(${scale})`;

                // 5. Create a new diagram and append it inside the clicked box
                const newDiagram = createDiagram();
                box.appendChild(newDiagram);
                
                // 6. After the zoom animation finishes, fade in the new diagram
                setTimeout(() => {
                    newDiagram.style.opacity = '1';
                }, 800); // Should match the transition delay in CSS
            }
        });

        // Create and append the initial diagram on page load
        viewport.appendChild(createDiagram());
    </script>
</body>
</html>
